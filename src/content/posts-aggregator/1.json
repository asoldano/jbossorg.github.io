{
  "title": "Toward a reliable and fully recoverable Drools stateful session",
  "link": "https://blog.kie.org/2023/05/toward-a-reliable-and-fully-recoverable-drools-stateful-session.html",
  "author": [
    {
      "name": "Mario Fusco",
      "avatar": null
    }
  ],
  "date": "2023-05-17T14:09:35.000Z",
  "feed_title": "KIE Community",
  "content": "One of the most important features of Drools is the possibility of evaluating rules in an interactive and conversational way, allowing to use inference to make iterative changes to facts over time and preserving the state of a session among different invocations. Actually this characteristic is so widely used, for instance when performing complex event processing, to be the default behavior of a .   The state of a session is of course made of many different data structures that live on the JVM heap. This implies that its lifespan is bound to the one of the hosting JVM and gets lost if for any reason the JVM itself, or more likely the machine, physical or virtual, on which that JVM is running, experiences a failure and is terminated.   This can be a serious limitation in the use of a stateful session, especially in a cloud environment where also the node running the session has to be considered ephemeral and can be killed at any moment. In this blog post we will introduce the implementation of a Drools reliable session that is capable of automatically persisting its internal state while it is running thus allowing it to recreate a new session from that persisted state when for any reason the original session becomes unavailable.   INTRODUCING DROOLS RELIABLE SESSION  The version 8.38.0.Final of Drools introduces a containing a first implementation of the Drools reliable session. At the moment it is made of 2 submodules. The first one defines the common API and general implementation of the reliable session, abstracting away the persistence layer in order to make it possible to plug different concrete implementations of this layer. The second provides one of such persistence layer implementations based on , while other modules relying on different technologies for persistence will be made available in future.  Through this module it is possible to create a reliable KieSession as it follows  KieSessionConfiguration conf = KieServices.get().newKieSessionConfiguration(); conf.setOption(PersistedSessionOption.newSession(PersistedSessionOption.Strategy.STORES_ONLY)); KieSession ksession = kbase.newKieSession(conf, null);  and start using it as any other normal Drools stateful session. The only requirement to resume this session after a JVM crash is keeping its identifier on the client side  long savedSessionId = session.getIdentifier();  so that it will be possible at a later time to recreate a new stateful session preserving the same state of the old one.  KieSessionConfiguration conf = KieServices.get().newKieSessionConfiguration(); conf.PersistedSessionOption.fromSession(savedSessionId, PersistedSessionOption.Strategy.STORES_ONLY)); KieSession ksession = kbase.newKieSession(conf, null);   PUTTING THE RELIABLE SESSION AT WORK IN THE CLOUD  As anticipated, this new capability for a Drools session of being reliable makes it a perfect fit for a cloud environment where a node hosting a long running stateful computation could suddenly die for many different reasons. When this happens another node can be started without losing any data of the old session and keeping using it as nothing happened.  To demonstrate how this works we developed a based on implementing a simple rule service to validate a set of loan applications and get the total amount of approved loans in a reliable stateful session. In this way the state of a session is persisted across different executions, so if the server is shut down and then restarted the state of an old session is not lost. This demo persists the state of a session using Infinispan running in embedded mode. This demo application can be also . While doing so you can try to scale to zero the deployment running this application. If you do so, of course the application won’t respond anymore to any further REST call, but scaling it up to one again the reliable session will automatically restore its state and the computation can continue as nothing happened. A video demonstrating how this works is available here:  The post appeared first on ."
}