{
  "title": "An object model marshaller for all occasions",
  "link": "http://feeds.athico.com/~r/droolsatom/~3/Q9xvy3l-yi4/an-object-model-marshaller-for-all-occasions.html",
  "author": [
    {
      "name": "Michael Anstis",
      "avatar": null
    }
  ],
  "date": "2021-09-14T18:29:32.000Z",
  "feed_title": "KIE Community",
  "content": "SCORECARDS  We have a new Scorecard .  It needs to load PMML XML and save it. Great. It’d be less than useful if it could not.  We also support of PMML XML models. Super. It’s nice to be able to actually execute models too.   THE PROBLEM  An object model marshaller for all occasions.  Our Scorecard example illustrates the problem clearly:  Two technologically disparate teams needing the same functionality yet duplicating effort.  \"Back-end\" developers choose their technology of choice and \"front-end\" developers choose theirs.  The end result is two code bases performing the same function.  Both needing maintenance and both at risk of diverging.  https://steins-gate.fandom.com/wiki/Divergence_Meter  Enter an object model marshaller for all occasions.   THERE IS A BETTER WAY!  We have been working on an approach to generate source code from an XSD.  We are able to generate source code for both the class model, a deserlializer to load it and serializer to save it.  The source code is then compiled for different target environments where it executes.  Single source. Single maintenance branch. No divergence.   THE APPROACH  We use XJC with a Maven Plugin to generate JAXB annotated classes from the XSD.  In our working we have chosen to generate both interfaces and concrete classes. The idea being that we can write further code against the interfaces but have concrete implementations to load and save different versions of the model. We then use the Maven Plugin to generate source code from the JAXB annotations to handle loading and saving.  We have a working prototype for PMML v4.4.   * The interfaces are generated .   * The classes, deserializers and serializers are generated .  Finally we can:   * GWT to compile the source code to run in a browser.   * J2CL to compile the source code to run in a browser.   * a Java Compiler to compile the source code to run in a JRE.  The post appeared first on .  "
}