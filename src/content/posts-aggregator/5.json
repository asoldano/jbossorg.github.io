{
  "title": "WildFly S2I new architecture is final!",
  "link": "https://wildfly.org//news/2022/04/20/WildFly-s2i-v2-Released/",
  "author": [
    {
      "name": "Jean-François Denise",
      "avatar": null
    }
  ],
  "date": "2022-04-20T00:00:00.000Z",
  "feed_title": "WildFly",
  "content": "NEW WILDFLY ON THE CLOUD ARCHITECTURE  We have released the new components that make for a completely redesigned WildFly cloud experience. This redesign allows for more flexibility, simpler workflows and smaller application images.  Our new cloud architecture is composed of 5 main components:   * New WildFly Source-to-Image (S2I) builder images ( and )   * New WildFly runtime images ( and )   * New   * New   * New  The new S2I workfow can be summarized as:   * Configure the WildFly Maven plugin to deploy your application in the WildFly    server of your choice, finely tuned according to your needs ()!   * Make your application sources available in a GIT repository ().   * Define a Helm Chart for WildFly yaml file ().   * Install your Helm file into OpenShift (). You are done!  To get you familiar with the various components you can directly jump to these . They will drive you through various use-cases from source to deployment on OpenShift (for immediate access to an OpenShift cluster, you can use ).   LEGACY WILDFLY S2I AND RUNTIME CENTOS7 IMAGES  We have released the legacy images for WildFly 26.1.0.Final in . We are not planning to release any centos7 images starting WildFly 27.  Note  When using the legacy S2I images for WildFly, you must stay on the 1.x version of the Helm Chart for WildFly:  helm install my-legacy-app -f helm.yaml wildfly/wildfly --version ^1.x   NEW WILDFLY S2I AND RUNTIME IMAGES  We have released our new based images:   * S2I builder image.   * S2I builder image.   * runtime image.   * runtime image.  S2I builder images and runtime images, although directly usable from docker build (an example of docker image built from a WildFly runtime image can be found ) or tooling, are best used when using Helm Chart for WildFly. Helm Chart create smart chained builds in order to output lightweight application images running on the runtime of your choice (JDK11 or JDK17).  Detailed documentation can be found .   UNIVERSAL BASE IMAGE 8 MINIMAL  Our new images are based on . The UBI8 image has been designed and engineered to be the base layer for containerized applications. The Minimal flavor is a stripped down image.   RELATIONSHIP WITH THE OPENJDK S2I IMAGES  Our new images are sharing the Java VM configuration with the . This has multiple benefits:   * JDK alignement. Benefit from latest updates.   * JVM configuration alignment. Benefit from the same automatic tuning and    configuration of Java VM.  In the end you are getting an homogeneous user experience whatever the kind of WildFly server packaging you have chosen: WildFly Bootable JAR that runs on the openjdk images or WildFly that runs on our new images.   AN S2I BUILDER IMAGE DECOUPLED FROM WILDFLY SERVER  S2I builder images are generic and can be used to deploy application for any WildFly server version.  Builder images have no dependency on a WildFly server release (as opposed to the legacy centos7 WildFly images that are bound to a given server version).  You can even run Jakarta EE8 or Jakarta EE9-based application from these images. The and are identical applications deployed on different kind of WildFly server. Just a matter of choosing the right Galleon feature-packs to assemble the right server.   RELEASE OF THE NEW IMAGES  Images release cadence is now decoupled from the WildFly server release cadence. Images have their own lifecycle. New releases will be done to address fixes and new features. Released images are deployed in the For the one that love to be on the bleeding edge we are constantly deploying images under development to the .   USING THE JDK 17 S2I BUILDER IMAGE  Applications are built and run similarly on JDK11 and JDK17. For JDK17 just make sure to have your maven projects to use 3.3.2 version for the . This shows how to configure the Maven war plugin version.  Note  When using the JDK17 image, you need to set the following env variable to workaround :  JAVA_OPTS_APPEND=--add-exports=jdk.naming.dns/com.sun.jndi.dns=ALL-UNNAMED   MULTIARCH IMAGES PREVIEW  We have released preview of Multiarch images (linux/amd64 and linux/arm64). Longer term we plan to make our official images multi arch and stop releasing the preview images, but we are not yet there.  Multi arch preview images:   * preview multi arch JDK11 S2I builder image.   * preview multi arch JDK17 S2I builder image.   * preview JDK11 multi arch runtime image.   * preview JDK17 multi arch runtime image.   NEW S2I BUILD WORKFLOW  In order to create a server to be installed into the WildFly image we are relying on the that can now provision a fully configured server containing your deployment. The WildFly Maven plugin 3.0.0.Final has been evolved with some new goals to provision, configure, and package the server and the deployment in one step. When designing your application pom file, add an execution of the WildFly Maven plugin package goal, configure it with the and , and optionally reference WildFly CLI scripts to be executed and content to be copied inside the server. At the end of the build you will get (by default in the target/server directory) a server with your app deployed, ready to be installed in the image.  In order to allow for a smooth transition to the new images, we are still supporting (in a deprecated way) the legacy workflow. Your existing application would work, but you are now required to specify the Galleon feature-pack(s) and layer(s) (GALLEON_PROVISION_FEATURE_PACKS and GALLEON_PROVISION_LAYERS env variables) you want to provision during the S2I build.   EXECUTION TIME SERVER CONFIGURATION  Application images built from the WildFly S2I builder or runtime images both expose the same API allowing you to fine tune the server execution. This API is exposed by means of environment variables to be set when configuring your deployment.   JVM CONFIGURATION API  The JVM that are used today with WildFly s2i images are still supported. They are a nice way to tune the JVM.   WILDFLY SERVER STARTUP CONFIGURATION API  The new server startup configuration API is described in this . This API comes with default values that should cover the main use-cases. 2 env variables open-up new possibilities:   * SERVER_ARGS allows you to pass WildFly server arguments when starting the    server.   * CLI_LAUNCH_SCRIPT allows you to provide a path (relative to JBOSS_HOME or    absolute) to a CLI script to be executed at startup time. Although CLI    scripts should be executed at build time from the WildFly Maven plugin, in    some cases it can be useful to adjust the configuration at execution time.    You can package a set of CLI scripts inside your server at build time, then    reference one of these CLI scripts to be executed at runtime.   WILDFLY SERVER SUBSYSTEMS CONFIGURATION API  If you are using WildFly s2i images you are perhaps asking yourself where are the env variables you have been using to configure the elytron subsystem, to add datasources, to configure logging or the microprofile-config subsystem,… They are provided by means of a new that you can combine with the WildFly Galleon feature-pack at build time to produce a server supporting these env variables.   * If you only provision org.wildfly:wildfly-galleon-pack:26.1.0.Final you will    get a \"vanilla\" WildFly server that will get lightly adjusted by the image    entrypoint to properly execute on OpenShift.   * If you provision org.wildfly:wildfly-galleon-pack:26.1.0.Final and    org.wildfly.cloud:wildfly-cloud-galleon-pack:1.0.0.Final you will get a    WildFly server for cloud execution ready to be configured thanks to the the    cloud feature-pack exposes.  2 variants exist of the cloud feature-pack:   * org.wildfly.cloud:wildfly-cloud-galleon-pack to be used with    org.wildfly:wildfly-galleon-pack to provision an EE8 server as shown in this    .   * org.wildfly.cloud:wildfly-preview-cloud-galleon-pack to be used with    org.wildfly:wildfly-preview-feature-pack to provision a Jakarta EE9 server as    shown in this .  Detailed documentation can be found .   EXAMPLES  We have defined a set of to help you get started. They cover different use-cases that highlight the new capabilities.  The examples rely on to automate the build and deployment on OpenShift.  In order to deploy the examples onto OpenShift, you can log in to the .  The use cases covered are:   * , an application that interacts with a postgresql database. The projects    shows how to provision a server configured in a way that is similar to the    default WildFly server presents in the legacy WildFly cento7 image.   * , highlights the steps needed to build a docker image that contains the    server and your application.   * , simple application.   * . Use WildFly elytron-oidc-client to interact with a Keycloak server. Also    highlights the ability to provide server arguments at launch time.   * . We all need to enable logging at some point. With a simple CLI script    executed at server boot time, enable logging and redirect all traces to the    CONSOLE.   * . Create a WildFly application with support for postgreSQL database.   * . Create a WildFly application with support for postgreSQL database. The    running server and application are both compliant with Jakarta EE9.   * . A cluster of PODS that share web sessions. This example benefits from the    WildFly cloud feature-pack and Helm Chart for WildFly capabilities to    automatically enable the dns.DNS_PING JGroups protocol and generate the ping    service.   ENJOY!  and… keep us posted with your feedback. (You can log these as new .)  Thank-you!  JF Denise"
}