{
  "title": "Infinispan 15.0.3.Final",
  "link": "https://infinispan.org/blog/2024/05/08/infinispan-15",
  "author": [
    {
      "name": "Tristan Tarrant",
      "avatar": "https://www.gravatar.com/avatar/b91126c20f0d38f1ce1750d5a2b2bcb8?s=50"
    }
  ],
  "date": "2024-05-08T00:00:00.000Z",
  "feed_title": "Infinispan",
  "content": "Since our 15 release a couple of months ago, we’ve been busy fixing bugs and adding new functionality. This post highlights the most notable enhancements:   PROTOCOL BUFFERS COMPATIBILITY CHECKS  When uploading new versions of existing schemas to Infinispan, these will be validated using a set of backwards-compatibility rules based upon . The types of checks can be configured via the schema-compatibility attribute of the global serialization configuration:  <infinispan>    <serialization schema-compatibility=\"UNRESTRICTED|LENIENT|STRICT\"/> </infinispan>  The available levels are:   * UNRESTRICTED: no checks are performed   * LENIENT: a subset of the rules are enforced   * STRICT: all the rules are enforced (default)   HTTP COMPRESSION/DECOMPRESSION  The REST endpoint has supported compressing responses since Infinispan 10, but now it also supports receiving compressed requests using the standard HTTP .   QUERY/INDEX BY KEY  Entry keys can now be indexed and referenced in Ickle queries:  select s.key.column from model.Structure s where s.key.zone = 'z7'   FILTERING IN VECTOR SEARCH  It’s now possible to limit vector searches by applying predicates to the kNN queries:  Query<Object[]> query = remoteCache.query(    \"select score(i), i from Item i where i.floatVector <-> [:a]~:k filtering (i.buggy : 'cat' or i.text : 'code')\"); query.setParameter(\"a\", new float[]{7, 7, 7}); query.setParameter(\"k\", 3);   MORE DETAILED METRICS  Metrics for reads/writes are now split into the following categories:   * primary owner   * backup owner   * non-owner  Additionally, transaction operations (prepare, commit and rollback) now have their own metrics for counts and response times.   CACHE ALIASES  Caches can now have aliases associated with them, so a cache may be accessed either by its primary name or one of its aliases. The aliases attribute can be manipulated at runtime using the CLI or the REST API, so you can reassign aliases to different caches. With this functionality it is possible to implement cache snapshots. Given the following configuration:  <caches>     <distributed-cache name=\"snapshot1\" aliases=\"data\" />     <distributed-cache name=\"snapshot2\"/> </caches>  Clients could be accessing an older snapshot through the data alias, while the other snapshot is being populated. Once the new snapshot cache is ready, reassign the data alias to it and clients will automatically see the new data.   REDIS PROTOCOL  Infinispan can now support multiple Redis databases, even in clustered mode (something that the original Redis cannot do). You can use the cache alias feature to assign logical database numbers to named caches.  We’ve also implemented a few more Redis commands:   * BLMPOP   * DB   * HSTRLEN   * PUBSUB   * PUBSUB NUMPAT  as well as fixing a number of buglets in other commands.   REACTIVE METHODS FOR SPRING CACHE  The Spring Cache (retrieve) methods have been implemented.   JDBC_PING AND DATASOURCES  Infinispan server can now inject a managed datasource into the JDBC_PING protocol:  <cache-container>     <transport stack=\"jdbc\" server:data-source=\"ds\" /> </cache-container>   REMOVAL OF OPENSSL  Infinispan server no longer ships with the OpenSSL wrapper: the performance of the JDK’s SSLEngine has been vastly improved in Java 17 to the point where there is no noticeable difference (and in some cases it is slightly faster, since it no longer needs to jump over JNI).   DOCUMENTATION  Many improvements, updates and fixes.   RELEASE NOTES  You can look at the to see what has changed since our latest CR.  Get them from our ."
}