{
  "title": "Kogito Task Deadlines",
  "link": "https://blog.kie.org/2021/08/kogito-task-deadlines.html",
  "author": [
    {
      "name": "Francisco Javier Tirado Sarti",
      "avatar": null
    }
  ],
  "date": "2021-08-10T18:27:58.000Z",
  "feed_title": "KIE Community",
  "content": "At the beginning of the second decade of the twenty-first century we can still claim that smart humans are more clever than average machines. On the other hand, we probably have to admit that any machine is more reliable as a scheduler and reminder than an average human. So, when we face a task that requires human intervention in order to be completed, it feels natural to be able to set up a machine to periodically warn the human that his clever assistance is required to fulfill the task on time. That’s precisely the purpose of Kogito task deadlines functionality.    DEADLINE DESCRIPTION  The basic idea behind deadlines is that when they expire, a notification is triggered. Hence, a deadline is composed of an expiration date, the type of occurrence and notification information.   The expiration date will either be an exact date (just one notification) or a period interval: bounded (by establishing a maximum number of notifications)  or unbounded (no limit of notifications). It is worth mentioning that when authoring the BPMN process, the human designer associates a deadline date to the task with the help of a graphical tool, but that internally the BPMN process is stored as a string following format. That’s the reason why the tool also allows advanced users, familiar with ISO 8601 syntax, to directly type it.   The deadline type can be “notStarted” or “notCompleted”. When the deadline date is reached, if type is “notStarted”, a notification is triggered if no phase transition has been performed over the task. “notCompleted” deadline types are triggered if the task is not completed. So we are essentially covering the two most common branches of human laziness: a task that has not been worked at all and a task that was started but left uncompleted.   The notification information is the data that will be included in the notification if it is eventually fired, which leads us to the question: what happens when a notification is triggered?. Kogito is handling the notification as a specific type of event: UserTaskDeadline. That event will contain task information plus the deadline notification information, which is a list of key-value pairs. These  values might contain MVEL expressions to be evaluated against the task information. Combining arbitrary information with the power of an expression language, the task notification event might be used for multiple purposes.   In fact, the way the task notification event is handled depends on the add-ons that are configured. By default Kogito does nothing, but it provides two addons to publish the event on a Kafka broker: and . Once it is published, someone should consume the notification event to do something useful with it. Kogito provides another pair of add-ons to send an email using notification information included in the deadline: and .  On summary, when task-notification and email addon are included in the project pom.xml for our target platform (Quarkus or Springboot) and a deadline is configured in the BPMN process, if a task is left unattended for a while, an email will be send. Let’s see how it works extending the approvals example from previous .    DEADLINE EXAMPLE.   As you probably recall, process defines a task called firstLineApproval. We are going to configure Kogito, using Quarkus as target platform, to send an email every minute till the firstLineApproval human task instance that is created at process startup is completed.    BPMN CONFIGURATION   The first thing to do is to update the bpmn process through the graphical editor. In the notification window associated with the firstLineApproval task, we can provide details about the deadline date plus the data needed to send an email.  As previously mentioned in the introduction, although the window is designed for email notifications, notifications are generic, meaning that fields specified in the graphical interface are internally handled as a generic key value pair list. This will allow developing custom extensions different from the email addon we are going to use in this example.   As you can see in the screenshots, we are telling Kogito to fire a notification every minute till the task is completed. When the period expires, an email to will be sent, reminding that lazy user that something needs to be done with the task.    ADD-ON CONFIGURATION   Once bpmn is properly configured,  we still need to set up the addons. Approvals project already has a notification profile that includes these dependencies.    <profile>     <id>notification</id>     <dependencies>             <dependency>                     <groupId>org.kie.kogito</groupId>                    <artifactId>mail-quarkus-addon</artifactId>             </dependency>             <dependency>                     <groupId>org.kie.kogito</groupId>                     <artifactId>task-notification-quarkus-addon</artifactId>         </dependency>         <dependency>                    <groupId>io.quarkus</groupId>                    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>         </dependency>       </dependencies>      </profile>    As you can see, since we are using Kafka as broker, we are selecting  task-notification-quarkus-addon, which uses smallrye library to define a channel called kogito-deadline-events, where an event containing the notification data is published into the configured Kafka topic (remember that by default topic name is the channel name)  Once we have an event being published into Kafka, we need to set up a listener that publishes the email upon event reception. We do that by including mail-quarkus-addon into project pom. This addon will consume kafka records published on kogito-deadline-events topic and send an email using the information contained in the kafka record.   Finally, we need to tell the mail addon the details of the smtp server to be used to send email. We do that by adding several properties to .  quarkus.mailer.host=localhost quarkus.mailer.port=25 quarkus.mailer.mock=false quarkus.mailer.ssl=false quarkus.mailer.start-tls=disabled   In this particular example, since I’m using , I’m setting up a local . A complete configuration reference for quarkus mailer, the underlying library being used for the mail addon, can be found .   When all this configuration is in place, once the process instance is started, if nothing else is done, after a minute the following e-mail appears in my account.    CONCLUSION   In this post we have learnt how to set up Kogito to send an email when a task has not been completed for a while. We also learned that this is just the tip of the iceberg, because task deadline notifications can be used for many other purposes, only limited by the creativity of developers willing to implement more addons.   The post appeared first on ."
}