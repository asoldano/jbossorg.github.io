{
  "title": "Serverless Workflow integration with Camel Routes",
  "link": "https://blog.kie.org/2023/02/serverless-workflow-integration-camel-routes.html",
  "author": [
    {
      "name": "Ricardo Zanini",
      "avatar": null
    }
  ],
  "date": "2023-02-10T17:58:06.000Z",
  "feed_title": "KIE Community",
  "content": "A recent addition to the Kogito Serverless Workflow is the ability to call !   WHEN TO USE CAMEL ROUTES  that provides to integrate with virtually any technology stack.  Kogito Serverless Workflow offers a few ways to make calls to remote services that expose standard interfaces such as OpenAPI and AsyncAPI.  Sometimes, you might need to make calls to legacy systems or specific services that require additional configuration, schema, or data structures so that the standard interfaces might not suffice.  For example, you might need to call a from the workflow. Without additional Java implementation in your Kogito workflow application, you won’t be able to make requests to this SOAP service directly.  What if you could explicitly declare in your workflow definition that your function is a call to a Camel route in your project context?   HOW THE INTEGRATION WORKS  Kogito Serverless Workflow has a new add-on capable of producing messages to a Camel Route within the same application instance.  For example, you have a Camel route in your project that can interface with a SOAP WebService like this one:   <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!-- might look like that we are using Spring, but we are not. The XML DSL is derived from there, though --> <routes xmlns=\"http://camel.apache.org/schema/spring\">   <route id=\"sendSoapMessage\">     <from uri=\"direct:numberToWords\"/>     <!-- Converting our body to the type expected by the SOAP interface -->     <bean beanType=\"java.math.BigInteger\" method=\"valueOf\"/>     <setHeader name=\"operationName\">       <constant>NumberToWords</constant>     </setHeader>     <toD uri=\"cxf://example.com?serviceClass=com.dataaccess.webservicesserver.NumberConversionSoapType&amp;wsdlURL=/wsdl/numberconversion.wsdl\"/>   </route> </routes>   Then, from the workflow definition, you can declare a function that produces messages to this route:   {   \"functions\": [     {       \"name\": \"callSoap\",       \"type\": \"custom\",       \"operation\": \"camel:direct:numberToWords\"     }   ] }   Notice the new custom function with a new operation type. The operation is a URI scheme composed of the constant \"camel:\", the \"direct:\" endpoint, and its name. Kogito Serverless Workflow only supports producing messages to a endpoint at this time.  To use this function in the State definition, you can refer to the function as you usually would:   {   \"states\": [     {       \"name\": \"start\",       \"type\": \"operation\",       \"actions\": [         {           \"functionRef\": {             \"refName\": \"callSoap\",             \"arguments\": {               \"body\": \"${ .number }\",               \"headers\": { \"header1\": \"value1\", \"header2\": \"value2\"}             }           }         }       ],       \"end\": true     }   ]}   The function arguments can have optional attributes, \"body\" and \"headers.\" These arguments will be constructed as part of the handled internally by the Kogito engine. The body can be any valid JSON object and the headers must be a key/value pair.  Your route is responsible for properly handling the message. In the example above, the body is the number contained in the JSON payload.  The route response must be a valid Java bean object that can be serialized to JSON or a primitive type. Note that a JSON string is a valid output. The data will be merged into the workflow context data in the response attribute, for example:   {     \"fruit\": \"orange\",     \"response\": { \"number\": 10 } }   , you will find more information about this scenario and the complete project example.   FINAL THOUGHTS  The Camel Kogito add-on complements our work of integrating with the. In the use case described in this post, the Camel route is tightly coupled to the workflow. If you need to reuse the route or have more complex interface interactions (such as a REST endpoint), you should use Camel-K and interact with the services via OpenAPI interfaces.  Overall, this new feature introduced by Kogito Serverless Workflow can solve many use cases and enable integration with any service interface or data format supported by Camel. It’s a new way of interacting with services that don’t have standard interfaces or formats available, all within the same application.  In a world where many companies are looking to modernize their architecture and lift to the cloud, we believe this new feature can help them through the journey. Leave a comment or open a thread on our if you have any questions.  The post appeared first on ."
}